// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.5.3
// - protoc             v3.19.4
// source: prom/v1/dict.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationDictCreateDict = "/api.prom.v1.Dict/CreateDict"
const OperationDictDeleteDict = "/api.prom.v1.Dict/DeleteDict"
const OperationDictGetDict = "/api.prom.v1.Dict/GetDict"
const OperationDictListDict = "/api.prom.v1.Dict/ListDict"
const OperationDictUpdateDict = "/api.prom.v1.Dict/UpdateDict"

type DictHTTPServer interface {
	CreateDict(context.Context, *CreateDictRequest) (*CreateDictReply, error)
	DeleteDict(context.Context, *DeleteDictRequest) (*DeleteDictReply, error)
	GetDict(context.Context, *GetDictRequest) (*GetDictReply, error)
	ListDict(context.Context, *ListDictRequest) (*ListDictReply, error)
	UpdateDict(context.Context, *UpdateDictRequest) (*UpdateDictReply, error)
}

func RegisterDictHTTPServer(s *http.Server, srv DictHTTPServer) {
	r := s.Route("/")
	r.POST("/prom/v1/dict", _Dict_CreateDict0_HTTP_Handler(srv))
	r.PUT("/prom/v1/dict/{id}", _Dict_UpdateDict0_HTTP_Handler(srv))
	r.DELETE("/prom/v1/dict/{id}", _Dict_DeleteDict0_HTTP_Handler(srv))
	r.GET("/prom/v1/dict/{id}", _Dict_GetDict0_HTTP_Handler(srv))
	r.POST("/prom/v1/dicts", _Dict_ListDict0_HTTP_Handler(srv))
}

func _Dict_CreateDict0_HTTP_Handler(srv DictHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateDictRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDictCreateDict)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateDict(ctx, req.(*CreateDictRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateDictReply)
		return ctx.Result(200, reply)
	}
}

func _Dict_UpdateDict0_HTTP_Handler(srv DictHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateDictRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDictUpdateDict)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateDict(ctx, req.(*UpdateDictRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateDictReply)
		return ctx.Result(200, reply)
	}
}

func _Dict_DeleteDict0_HTTP_Handler(srv DictHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteDictRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDictDeleteDict)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteDict(ctx, req.(*DeleteDictRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteDictReply)
		return ctx.Result(200, reply)
	}
}

func _Dict_GetDict0_HTTP_Handler(srv DictHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetDictRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDictGetDict)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetDict(ctx, req.(*GetDictRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetDictReply)
		return ctx.Result(200, reply)
	}
}

func _Dict_ListDict0_HTTP_Handler(srv DictHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListDictRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationDictListDict)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListDict(ctx, req.(*ListDictRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListDictReply)
		return ctx.Result(200, reply)
	}
}

type DictHTTPClient interface {
	CreateDict(ctx context.Context, req *CreateDictRequest, opts ...http.CallOption) (rsp *CreateDictReply, err error)
	DeleteDict(ctx context.Context, req *DeleteDictRequest, opts ...http.CallOption) (rsp *DeleteDictReply, err error)
	GetDict(ctx context.Context, req *GetDictRequest, opts ...http.CallOption) (rsp *GetDictReply, err error)
	ListDict(ctx context.Context, req *ListDictRequest, opts ...http.CallOption) (rsp *ListDictReply, err error)
	UpdateDict(ctx context.Context, req *UpdateDictRequest, opts ...http.CallOption) (rsp *UpdateDictReply, err error)
}

type DictHTTPClientImpl struct {
	cc *http.Client
}

func NewDictHTTPClient(client *http.Client) DictHTTPClient {
	return &DictHTTPClientImpl{client}
}

func (c *DictHTTPClientImpl) CreateDict(ctx context.Context, in *CreateDictRequest, opts ...http.CallOption) (*CreateDictReply, error) {
	var out CreateDictReply
	pattern := "/prom/v1/dict"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDictCreateDict))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DictHTTPClientImpl) DeleteDict(ctx context.Context, in *DeleteDictRequest, opts ...http.CallOption) (*DeleteDictReply, error) {
	var out DeleteDictReply
	pattern := "/prom/v1/dict/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDictDeleteDict))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DictHTTPClientImpl) GetDict(ctx context.Context, in *GetDictRequest, opts ...http.CallOption) (*GetDictReply, error) {
	var out GetDictReply
	pattern := "/prom/v1/dict/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationDictGetDict))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DictHTTPClientImpl) ListDict(ctx context.Context, in *ListDictRequest, opts ...http.CallOption) (*ListDictReply, error) {
	var out ListDictReply
	pattern := "/prom/v1/dicts"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDictListDict))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *DictHTTPClientImpl) UpdateDict(ctx context.Context, in *UpdateDictRequest, opts ...http.CallOption) (*UpdateDictReply, error) {
	var out UpdateDictReply
	pattern := "/prom/v1/dict/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationDictUpdateDict))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
