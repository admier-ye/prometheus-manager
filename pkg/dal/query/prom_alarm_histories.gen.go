// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"strings"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"prometheus-manager/pkg/dal/model"
)

func newPromAlarmHistory(db *gorm.DB, opts ...gen.DOOption) promAlarmHistory {
	_promAlarmHistory := promAlarmHistory{}

	_promAlarmHistory.promAlarmHistoryDo.UseDB(db, opts...)
	_promAlarmHistory.promAlarmHistoryDo.UseModel(&model.PromAlarmHistory{})

	tableName := _promAlarmHistory.promAlarmHistoryDo.TableName()
	_promAlarmHistory.ALL = field.NewAsterisk(tableName)
	_promAlarmHistory.ID = field.NewInt32(tableName, "id")
	_promAlarmHistory.Node = field.NewString(tableName, "node")
	_promAlarmHistory.Status = field.NewString(tableName, "status")
	_promAlarmHistory.Info = field.NewString(tableName, "info")
	_promAlarmHistory.CreatedAt = field.NewTime(tableName, "created_at")
	_promAlarmHistory.StartAt = field.NewInt64(tableName, "start_at")
	_promAlarmHistory.EndAt = field.NewInt64(tableName, "end_at")
	_promAlarmHistory.Duration = field.NewInt64(tableName, "duration")
	_promAlarmHistory.StrategyID = field.NewInt32(tableName, "strategy_id")
	_promAlarmHistory.LevelID = field.NewInt32(tableName, "level_id")
	_promAlarmHistory.Md5 = field.NewString(tableName, "md5")
	_promAlarmHistory.Pages = promAlarmHistoryManyToManyPages{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Pages", "model.PromAlarmPage"),
	}

	_promAlarmHistory.fillFieldMap()

	return _promAlarmHistory
}

type promAlarmHistory struct {
	promAlarmHistoryDo

	ALL        field.Asterisk
	ID         field.Int32
	Node       field.String // node名称
	Status     field.String // 告警消息状态, 报警和恢复
	Info       field.String // 原始告警消息
	CreatedAt  field.Time   // 创建时间
	StartAt    field.Int64  // 报警开始时间
	EndAt      field.Int64  // 报警恢复时间
	Duration   field.Int64  // 持续时间时间戳, 没有恢复, 时间戳是0
	StrategyID field.Int32  // 规则ID, 用于查询时候
	LevelID    field.Int32  // 报警等级ID
	Md5        field.String // md5
	Pages      promAlarmHistoryManyToManyPages

	fieldMap map[string]field.Expr
}

func (p promAlarmHistory) Table(newTableName string) *promAlarmHistory {
	p.promAlarmHistoryDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p promAlarmHistory) As(alias string) *promAlarmHistory {
	p.promAlarmHistoryDo.DO = *(p.promAlarmHistoryDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *promAlarmHistory) updateTableName(table string) *promAlarmHistory {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt32(table, "id")
	p.Node = field.NewString(table, "node")
	p.Status = field.NewString(table, "status")
	p.Info = field.NewString(table, "info")
	p.CreatedAt = field.NewTime(table, "created_at")
	p.StartAt = field.NewInt64(table, "start_at")
	p.EndAt = field.NewInt64(table, "end_at")
	p.Duration = field.NewInt64(table, "duration")
	p.StrategyID = field.NewInt32(table, "strategy_id")
	p.LevelID = field.NewInt32(table, "level_id")
	p.Md5 = field.NewString(table, "md5")

	p.fillFieldMap()

	return p
}

func (p *promAlarmHistory) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *promAlarmHistory) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 12)
	p.fieldMap["id"] = p.ID
	p.fieldMap["node"] = p.Node
	p.fieldMap["status"] = p.Status
	p.fieldMap["info"] = p.Info
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["start_at"] = p.StartAt
	p.fieldMap["end_at"] = p.EndAt
	p.fieldMap["duration"] = p.Duration
	p.fieldMap["strategy_id"] = p.StrategyID
	p.fieldMap["level_id"] = p.LevelID
	p.fieldMap["md5"] = p.Md5

}

func (p promAlarmHistory) clone(db *gorm.DB) promAlarmHistory {
	p.promAlarmHistoryDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p promAlarmHistory) replaceDB(db *gorm.DB) promAlarmHistory {
	p.promAlarmHistoryDo.ReplaceDB(db)
	return p
}

type promAlarmHistoryManyToManyPages struct {
	db *gorm.DB

	field.RelationField
}

func (a promAlarmHistoryManyToManyPages) Where(conds ...field.Expr) *promAlarmHistoryManyToManyPages {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a promAlarmHistoryManyToManyPages) WithContext(ctx context.Context) *promAlarmHistoryManyToManyPages {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a promAlarmHistoryManyToManyPages) Session(session *gorm.Session) *promAlarmHistoryManyToManyPages {
	a.db = a.db.Session(session)
	return &a
}

func (a promAlarmHistoryManyToManyPages) Model(m *model.PromAlarmHistory) *promAlarmHistoryManyToManyPagesTx {
	return &promAlarmHistoryManyToManyPagesTx{a.db.Model(m).Association(a.Name())}
}

type promAlarmHistoryManyToManyPagesTx struct{ tx *gorm.Association }

func (a promAlarmHistoryManyToManyPagesTx) Find() (result []*model.PromAlarmPage, err error) {
	return result, a.tx.Find(&result)
}

func (a promAlarmHistoryManyToManyPagesTx) Append(values ...*model.PromAlarmPage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a promAlarmHistoryManyToManyPagesTx) Replace(values ...*model.PromAlarmPage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a promAlarmHistoryManyToManyPagesTx) Delete(values ...*model.PromAlarmPage) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a promAlarmHistoryManyToManyPagesTx) Clear() error {
	return a.tx.Clear()
}

func (a promAlarmHistoryManyToManyPagesTx) Count() int64 {
	return a.tx.Count()
}

type promAlarmHistoryDo struct{ gen.DO }

type IPromAlarmHistoryDo interface {
	gen.SubQuery
	Debug() IPromAlarmHistoryDo
	WithContext(ctx context.Context) IPromAlarmHistoryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IPromAlarmHistoryDo
	WriteDB() IPromAlarmHistoryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IPromAlarmHistoryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IPromAlarmHistoryDo
	Not(conds ...gen.Condition) IPromAlarmHistoryDo
	Or(conds ...gen.Condition) IPromAlarmHistoryDo
	Select(conds ...field.Expr) IPromAlarmHistoryDo
	Where(conds ...gen.Condition) IPromAlarmHistoryDo
	Order(conds ...field.Expr) IPromAlarmHistoryDo
	Distinct(cols ...field.Expr) IPromAlarmHistoryDo
	Omit(cols ...field.Expr) IPromAlarmHistoryDo
	Join(table schema.Tabler, on ...field.Expr) IPromAlarmHistoryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IPromAlarmHistoryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IPromAlarmHistoryDo
	Group(cols ...field.Expr) IPromAlarmHistoryDo
	Having(conds ...gen.Condition) IPromAlarmHistoryDo
	Limit(limit int) IPromAlarmHistoryDo
	Offset(offset int) IPromAlarmHistoryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IPromAlarmHistoryDo
	Unscoped() IPromAlarmHistoryDo
	Create(values ...*model.PromAlarmHistory) error
	CreateInBatches(values []*model.PromAlarmHistory, batchSize int) error
	Save(values ...*model.PromAlarmHistory) error
	First() (*model.PromAlarmHistory, error)
	Take() (*model.PromAlarmHistory, error)
	Last() (*model.PromAlarmHistory, error)
	Find() ([]*model.PromAlarmHistory, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PromAlarmHistory, err error)
	FindInBatches(result *[]*model.PromAlarmHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.PromAlarmHistory) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IPromAlarmHistoryDo
	Assign(attrs ...field.AssignExpr) IPromAlarmHistoryDo
	Joins(fields ...field.RelationField) IPromAlarmHistoryDo
	Preload(fields ...field.RelationField) IPromAlarmHistoryDo
	FirstOrInit() (*model.PromAlarmHistory, error)
	FirstOrCreate() (*model.PromAlarmHistory, error)
	FindByPage(offset int, limit int) (result []*model.PromAlarmHistory, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IPromAlarmHistoryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler

	SaFindById(ctx context.Context, id int32) (result *model.PromAlarmHistory, err error)
}

// select * from @@table where id = @id
func (p promAlarmHistoryDo) SaFindById(ctx context.Context, id int32) (result *model.PromAlarmHistory, err error) {
	var params []interface{}

	var generateSQL strings.Builder
	params = append(params, id)
	generateSQL.WriteString("select * from prom_alarm_histories where id = ? ")

	var executeSQL *gorm.DB
	executeSQL = p.UnderlyingDB().Raw(generateSQL.String(), params...).Take(&result) // ignore_security_alert
	err = executeSQL.Error

	return
}

func (p promAlarmHistoryDo) Debug() IPromAlarmHistoryDo {
	return p.withDO(p.DO.Debug())
}

func (p promAlarmHistoryDo) WithContext(ctx context.Context) IPromAlarmHistoryDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p promAlarmHistoryDo) ReadDB() IPromAlarmHistoryDo {
	return p.Clauses(dbresolver.Read)
}

func (p promAlarmHistoryDo) WriteDB() IPromAlarmHistoryDo {
	return p.Clauses(dbresolver.Write)
}

func (p promAlarmHistoryDo) Session(config *gorm.Session) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Session(config))
}

func (p promAlarmHistoryDo) Clauses(conds ...clause.Expression) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p promAlarmHistoryDo) Returning(value interface{}, columns ...string) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p promAlarmHistoryDo) Not(conds ...gen.Condition) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p promAlarmHistoryDo) Or(conds ...gen.Condition) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p promAlarmHistoryDo) Select(conds ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p promAlarmHistoryDo) Where(conds ...gen.Condition) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p promAlarmHistoryDo) Order(conds ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p promAlarmHistoryDo) Distinct(cols ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p promAlarmHistoryDo) Omit(cols ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p promAlarmHistoryDo) Join(table schema.Tabler, on ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p promAlarmHistoryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p promAlarmHistoryDo) RightJoin(table schema.Tabler, on ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p promAlarmHistoryDo) Group(cols ...field.Expr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p promAlarmHistoryDo) Having(conds ...gen.Condition) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p promAlarmHistoryDo) Limit(limit int) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p promAlarmHistoryDo) Offset(offset int) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p promAlarmHistoryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p promAlarmHistoryDo) Unscoped() IPromAlarmHistoryDo {
	return p.withDO(p.DO.Unscoped())
}

func (p promAlarmHistoryDo) Create(values ...*model.PromAlarmHistory) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p promAlarmHistoryDo) CreateInBatches(values []*model.PromAlarmHistory, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p promAlarmHistoryDo) Save(values ...*model.PromAlarmHistory) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p promAlarmHistoryDo) First() (*model.PromAlarmHistory, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.PromAlarmHistory), nil
	}
}

func (p promAlarmHistoryDo) Take() (*model.PromAlarmHistory, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.PromAlarmHistory), nil
	}
}

func (p promAlarmHistoryDo) Last() (*model.PromAlarmHistory, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.PromAlarmHistory), nil
	}
}

func (p promAlarmHistoryDo) Find() ([]*model.PromAlarmHistory, error) {
	result, err := p.DO.Find()
	return result.([]*model.PromAlarmHistory), err
}

func (p promAlarmHistoryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.PromAlarmHistory, err error) {
	buf := make([]*model.PromAlarmHistory, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p promAlarmHistoryDo) FindInBatches(result *[]*model.PromAlarmHistory, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p promAlarmHistoryDo) Attrs(attrs ...field.AssignExpr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p promAlarmHistoryDo) Assign(attrs ...field.AssignExpr) IPromAlarmHistoryDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p promAlarmHistoryDo) Joins(fields ...field.RelationField) IPromAlarmHistoryDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p promAlarmHistoryDo) Preload(fields ...field.RelationField) IPromAlarmHistoryDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p promAlarmHistoryDo) FirstOrInit() (*model.PromAlarmHistory, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.PromAlarmHistory), nil
	}
}

func (p promAlarmHistoryDo) FirstOrCreate() (*model.PromAlarmHistory, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.PromAlarmHistory), nil
	}
}

func (p promAlarmHistoryDo) FindByPage(offset int, limit int) (result []*model.PromAlarmHistory, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p promAlarmHistoryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p promAlarmHistoryDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p promAlarmHistoryDo) Delete(models ...*model.PromAlarmHistory) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *promAlarmHistoryDo) withDO(do gen.Dao) *promAlarmHistoryDo {
	p.DO = *do.(*gen.DO)
	return p
}
